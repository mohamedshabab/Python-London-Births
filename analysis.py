# -*- coding: utf-8 -*-
"""Copy of Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JgarrlM-fSOn0JHPw6KFd01dkiDKC3Iu

## **üì¶ Used Libraries**
These libraries form the core tools used in this project.  
**pandas** is used for loading and cleaning the datasets, **numpy** handles numerical operations, and **matplotlib** is used to create the visualisations in the analysis.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""## **üìÅ Loading the Datasets**

Below is a quick overview of each dataset used in this project:

- **births.xlsx** ‚Äî Borough‚Äëlevel birth counts and fertility rates  
- **ethnicity.xlsx** ‚Äî Population ethnicity percentages for each borough  
- **housing.xlsx** ‚Äî Housing affordability ratios (price‚Äëto‚Äëincome)  
- **md.xlsx** ‚Äî IMD 2019 deprivation scores by borough  
- **gender.xlsx** ‚Äî Male and female birth counts for sex‚Äëbased analysis  
- **livebirthsfinal.xlsx** ‚Äî Long‚Äëterm historical birth data used for trend modelling  
"""

births = pd.read_excel("/content/births.xlsx")
ethnicity = pd.read_excel("/content/ethnicity.xlsx")
imd = pd.read_excel("/content/md.xlsx")
housing = pd.read_excel("/content/housing.xlsx")
gender = pd.read_excel("/content/gender.xlsx")

livebirthsfinal = pd.read_excel("/content/livebirthsfinal.xlsx")

"""## **üßπ Cleaning Column Names**

Before analysing the datasets, all column names are converted to lowercase and stripped of extra spaces.  
This ensures consistency across files and prevents errors when merging or selecting columns.

"""

def clean_cols(df):
    df = df.copy()
    df.columns = [str(c).strip().lower() for c in df.columns]
    return df

births = clean_cols(births)
ethnicity = clean_cols(ethnicity)
imd = clean_cols(imd)
housing = clean_cols(housing)
gender = clean_cols(gender)
livebirthsfinal = clean_cols(livebirthsfinal)

"""## **üìç Standardising Borough Names**
Each dataset labels boroughs differently.  
To avoid merge errors, all borough columns are renamed to a shared **`borough`** field, extra spaces are removed, and only the 32 official London boroughs are kept for analysis.
"""

# List of London boroughs used in the analysis
LONDON_BOROUGHS = [
    "Barking and Dagenham", "Barnet", "Bexley", "Brent", "Bromley",
    "Camden", "Croydon", "Ealing", "Enfield", "Greenwich",
    "Hackney", "Hammersmith and Fulham", "Haringey", "Harrow",
    "Havering", "Hillingdon", "Hounslow", "Islington",
    "Kensington and Chelsea", "Kingston upon Thames", "Lambeth",
    "Lewisham", "Merton", "Newham", "Redbridge",
    "Richmond upon Thames", "Southwark", "Sutton",
    "Tower Hamlets", "Waltham Forest", "Wandsworth", "Westminster"
]

# Rename borough column in each dataset (based on the columns you printed)
# births already has 'borough', so no change needed there
ethnicity = ethnicity.rename(columns={"2022 local authorities: district": "borough"})
# imd already has 'borough'
# housing already has 'borough'
gender    = gender.rename(columns={"local authority": "borough"})

# Standardise borough names and filter ‚Äì make sure we write back to each df
datasets = [("births", births),
            ("ethnicity", ethnicity),
            ("imd", imd),
            ("housing", housing),
            ("gender", gender)]

for name, df in datasets:
    df["borough"] = df["borough"].astype(str).str.strip()
    df = df[df["borough"].isin(LONDON_BOROUGHS)]
    globals()[name] = df   # update the real variable

# quick check
print(len(births), len(ethnicity), len(imd), len(housing), len(gender))

"""## **üìä Merging the Datasets**

After cleaning and standardising all files, we merge the borough‚Äëlevel datasets into one combined dataframe.  
This allows us to analyse relationships between births, ethnicity, deprivation, and housing affordability in a single place.
"""

# Merge main borough-level datasets on the 'borough' column
df = (
    births
        .merge(ethnicity, on="borough", how="left")
        .merge(imd,       on="borough", how="left")
        .merge(housing,   on="borough", how="left")
)

# Check the shape and first few rows
print("Merged shape:", df.shape)
df.head()

"""## **üî¢ Converting Columns to Numeric**

Before creating visualisations, key columns are converted to numeric types.  
This ensures calculations, sorting, and correlations work correctly without errors.

"""

# Check current columns
print(df.columns.tolist())

numeric_cols = [
    "2023",
    "2024",
    "total: all usual residents",
    "imd - average score",
    "2023 ratio"
]

for col in numeric_cols:
    df[col] = pd.to_numeric(df[col], errors="coerce")

df[numeric_cols].head()

"""## üßæ Overview of the Merged Dataset

The merged dataframe now combines births, ethnicity, deprivation, and housing data for each London borough.

- **Rows:** 32 (one for each London borough)  
- **Columns:** 51 variables in total  
- **Key columns include:**
  - `2023`, `2024` ‚Äì recent birth or fertility rates  
  - `total: all usual residents` ‚Äì borough population  
  - Ethnicity percentages:
    - `asian, asian british or asian welsh`
    - `black, black british, black welsh, caribbean or african`
    - `mixed or multiple ethnic groups`
    - `white`
    - `other ethnic group`
  - Deprivation:
    - `imd - average score`
  - Housing:
    - `2023 ratio` ‚Äì housing affordability (price‚Äëto‚Äëincome)

This cleaned and merged dataset will be used as the basis for all visualisations and statistical analysis in the next sections.

"""

df.info()
df.head()

"""# üìä Top 5 and Bottom 5 Boroughs by Birth Rate (2024)

This visual compares the five boroughs with the **highest** birth rates to the five with the **lowest** in 2024.  
The top-performing areas (in green) show significantly higher fertility levels, while the bottom-performing areas (in red) have noticeably lower rates.  
This helps highlight regional differences and identify where birth rates are rising or declining across London.

"""

import matplotlib.pyplot as plt

# Sort by 2024 birth rate (high ‚Üí low)
df_sorted = df.sort_values("2024", ascending=False)

# Select top 5 and bottom 5
top5 = df_sorted.head(5)
bottom5 = df_sorted.tail(5)

# Combine
combined = pd.concat([top5, bottom5])

# Create colour list: green for top 5, red for bottom 5
colors = ["#2b8a3e"] * 5 + ["#d00000"] * 5

# Plot
plt.figure(figsize=(10,6))
plt.barh(combined["borough"], combined["2024"], color=colors)

plt.xlabel("Birth rate / TFR 2024")
plt.title("Top 5 and Bottom 5 London Boroughs by Birth Rate (2024)")

plt.gca().invert_yaxis()  # highest values at top
plt.grid(axis="x", linestyle="--", alpha=0.4)

plt.tight_layout()
plt.show()

"""# üë• Ethnicity-Weighted Birth Distribution (2024)

This chart shows the estimated ethnic distribution of births across London in 2024.  
The calculation weights each borough‚Äôs ethnic composition by its birth level, giving a more accurate picture of which groups contribute most to total births.  
This approach reflects the real demographic impact rather than simple population percentages.

"""

import matplotlib.pyplot as plt

# Ethnicity percentage columns
eth_cols = [
    "white",
    "asian, asian british or asian welsh",
    "black, black british, black welsh, caribbean or african",
    "mixed or multiple ethnic groups",
    "other ethnic group"
]

# Make sure columns are numeric
df["2024"] = pd.to_numeric(df["2024"], errors="coerce")
for col in eth_cols:
    df[col] = pd.to_numeric(df[col], errors="coerce")

# Drop rows with missing birth data
df_birth = df.dropna(subset=["2024"])

# Weighted ethnicity calculation
weighted = {}
total_weight = df_birth["2024"].sum()

for col in eth_cols:
    weighted[col] = (df_birth[col] * df_birth["2024"]).sum() / total_weight

# Prepare values
labels = ["White", "Asian", "Black", "Mixed", "Other"]
values = [
    weighted["white"],
    weighted["asian, asian british or asian welsh"],
    weighted["black, black british, black welsh, caribbean or african"],
    weighted["mixed or multiple ethnic groups"],
    weighted["other ethnic group"],
]

# Pie chart
plt.figure(figsize=(7,7))
plt.pie(values, labels=labels, autopct="%1.1f%%", startangle=90)
plt.title("Estimated Ethnic Distribution of Births (2024)\nWeighted by Borough Birth Levels")
plt.tight_layout()
plt.show()

"""# üë∂ Births by Sex in London (2022‚Äì2023)

This visual shows the proportion of male and female births across London using the gender dataset.  
The values are summed across all boroughs to give an overall distribution.  
This helps illustrate whether there is a gender imbalance in births during the period.

"""

import matplotlib.pyplot as plt

# Identify male and female birth columns
male_cols = ['male first child', 'male second child', 'male third or more']
female_cols = ['female first child', 'female second child', 'female third or more']

# Convert to numeric
for col in male_cols + female_cols:
    gender[col] = pd.to_numeric(gender[col], errors='coerce')

# Sum all male and female births across London
total_males = gender[male_cols].sum().sum()
total_females = gender[female_cols].sum().sum()

# Plot pie chart
plt.figure(figsize=(6,6))
plt.pie(
    [total_males, total_females],
    labels=['Male Births', 'Female Births'],
    autopct='%1.1f%%',
    colors=['skyblue','lightpink'],
    startangle=90
)
plt.title("Births by Sex in London (2022‚Äì2023)")
plt.show()

"""# üìâ London Live Births: Historical Trend and Forecast (1993‚Äì2028)

This section shows the long-term trend in total live births across London.  
Real data comes from 1993‚Äì2023 (including the official ONS figure for 2022 and the provisional estimate for 2023).  
A polynomial trend line is fitted to the full series, and future values for 2024‚Äì2028 are forecasted.  

This forecast helps illustrate whether London is likely to see a continued decline, stabilisation, or growth in births over the next few years.

"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

# LOAD HISTORICAL DATA (1993‚Äì2021)
df_raw = pd.read_excel("/content/livebirthsfinal.xlsx")

# Convert Period "1992-1993" ‚Üí Year = 1993
df = df_raw.copy()
df["Year"] = df["Period"].str.split("-").str[1].astype(int)

# Keep only London boroughs (codes starting with E09)
df["Local authority code"] = df["Local authority code"].astype(str)
df_london = df[df["Local authority code"].str.startswith("E09")].copy()

# Sum age groups to get total births per borough per year
age_cols = df_london.columns[3:-1]
df_london["Total_births"] = df_london[age_cols].sum(axis=1)

# Aggregate to LONDON TOTAL
df_hist = (
    df_london.groupby("Year")["Total_births"]
    .sum()
    .reset_index()
    .sort_values("Year")
)

# INSERT REAL 2022 + PROVISIONAL 2023 NUMBERS
extra_years = pd.DataFrame({
    "Year": [2022, 2023],
    "Total_births": [110900, 109000]  # OFFICIAL 2022 + PROVISIONAL 2023
})

# Combine datasets
df_all = pd.concat([df_hist, extra_years], ignore_index=True)
df_all = df_all.sort_values("Year")

# FIT POLYNOMIAL TREND (USE ALL REAL YEARS)
# ---------------------------------------------------------
X = df_all["Year"].values.reshape(-1, 1)
y = df_all["Total_births"].values

degree = 2   # smooth + realistic
poly = PolynomialFeatures(degree)
X_poly = poly.fit_transform(X)

model = LinearRegression()
model.fit(X_poly, y)

# Predict smoothed trend for historical years
y_pred = model.predict(X_poly)

# FORECAST 2024‚Äì2028
future_years = np.arange(2024, 2029)
X_future_poly = poly.transform(future_years.reshape(-1, 1))
y_future = model.predict(X_future_poly)

# FINAL PLOT

plt.figure(figsize=(12, 6))

# Actual births
plt.plot(
    df_all["Year"], y,
    marker="o", linestyle="-", linewidth=2,
    color="blue", label="Actual live births (1993‚Äì2023)"
)

# Trend line
plt.plot(
    df_all["Year"], y_pred,
    color="orange", linewidth=2,
    label="Trend (polynomial fit)"
)

# Forecast
plt.plot(
    future_years, y_future,
    marker="o", linestyle="--",
    color="orange", label="Forecast 2024‚Äì2028"
)

plt.title("Total Live Births in London ‚Äì Trend and Forecast (1993‚Äì2028)")
plt.xlabel("Year")
plt.ylabel("Number of live births")
plt.grid(True, linestyle="--", alpha=0.4)
plt.legend()
plt.tight_layout()
plt.show()

"""## üè° Housing Affordability, Birth Rate and Deprivation (Bubble Chart)

This chart compares London boroughs across three key factors:

- **Housing Affordability Ratio (2023)** ‚Äì shown on the X‚Äëaxis  
- **Birth Rate / TFR (2024)** ‚Äì shown on the Y‚Äëaxis  
- **Bubble Size:** Represents the birth rate (larger bubbles = higher birth rates)  
- **Bubble Colour (IMD Score):** Shows deprivation level  
  - Lighter colours = less deprived  
  - Darker colours = more deprived  

Each bubble represents a London borough.  
The smart labels help identify boroughs without overlap.

This visual helps reveal patterns between affordability, deprivation, and birth outcomes across London.

"""

!pip install adjustText

x = df_borough["2023 ratio"]                 # housing affordability
y = df_borough["2024"]                       # birth rate
imd = df_borough["imd - average score"]      # deprivation
sizes = df_borough["2024"] * 40              # bubble size
boroughs = df_borough["borough"]             # labels

# --- SCATTER PLOT ---
plt.figure(figsize=(11, 7))

scatter = plt.scatter(
    x, y,
    s=sizes,
    c=imd,
    cmap="viridis",
    alpha=0.7,
    edgecolors="black",
    linewidth=0.6
)

texts = []
for x_i, y_i, name in zip(x, y, boroughs):
    texts.append(plt.text(x_i, y_i, name, fontsize=7))

adjust_text(
    texts,
    expand_points=(9, 9),
    expand_text=(4, 9),
    arrowprops=dict(
        arrowstyle="-",
        color="gray",
        lw=0.5,
        alpha=0.8
    )
)

plt.xlabel("Housing Affordability Ratio (2023)")
plt.ylabel("Birth Rate (2024)")
plt.title("Housing Affordability vs Birth Rate\nBubble Size = Birth Rate, Colour = IMD")

plt.grid(True, linestyle="--", alpha=0.3)
cbar = plt.colorbar(scatter)
cbar.set_label("IMD Average Score (Higher = More Deprived)")

plt.tight_layout()
plt.show()

